from __future__ import annotations

import json
import os
import time
from pathlib import Path
from typing import Any, Dict

ROOT = Path(__file__).resolve().parents[2]
STATE = ROOT / "state"
OUT_PATH = STATE / "fleet_snapshot.json"
CFG = ROOT / "config" / "fleet_manifest.yaml"

def _now_ms() -> int:
    return int(time.time() * 1000)

def _load_json(path: Path) -> Dict[str, Any]:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {}

def _stat(path: Path) -> Dict[str, Any]:
    try:
        st = path.stat()
        mtime_ms = int(st.st_mtime * 1000)
        age_ms = max(0, _now_ms() - mtime_ms)
        return {"exists": True, "path": str(path), "size": int(st.st_size), "mtime_ms": mtime_ms, "age_ms": age_ms}
    except Exception:
        return {"exists": False, "path": str(path), "size": 0, "mtime_ms": None, "age_ms": None}

def _read_manifest_rows() -> list[dict[str, Any]]:
    """
    Loads config/fleet_manifest.yaml and returns list of fleet rows.
    Best-effort: requires PyYAML. If missing, falls back to label-only parse.
    """
    if not CFG.exists():
        return []

    # Try YAML first (correct)
    try:
        import yaml  # type: ignore
        d = yaml.safe_load(CFG.read_text(encoding="utf-8", errors="ignore")) or {}
        fleet = d.get("fleet") or []
        if not isinstance(fleet, list):
            return []
        out: list[dict[str, Any]] = []
        for row in fleet:
            if isinstance(row, dict):
                out.append(row)
        return out
    except Exception:
        # Fallback: label-only scan (legacy)
        labels: list[str] = []
        for line in CFG.read_text(encoding="utf-8", errors="ignore").splitlines():
            t = line.strip()
            if t.startswith("account_label:"):
                lbl = t.split(":", 1)[1].strip().strip("'").strip('"')
                if lbl:
                    labels.append(lbl)
        seen = set()
        uniq = []
        for x in labels:
            if x not in seen:
                seen.add(x)
                uniq.append(x)
        return [{"account_label": x} for x in uniq]
def main() -> int:
    STATE.mkdir(parents=True, exist_ok=True)

    buses = {
        "heartbeats": _stat(STATE / "heartbeats.json"),
        "ops_snapshot": _stat(STATE / "ops_snapshot.json"),
        "orderbook_bus": _stat(STATE / "orderbook_bus.json"),
        "positions_bus": _stat(STATE / "positions_bus.json"),
        "trades_bus": _stat(STATE / "trades_bus.json"),
    }

    rows = _read_manifest_rows()
    subs: Dict[str, Any] = {}

    # Labels from manifest rows (preserve manifest order)
    labels: list[str] = []
    for r in rows:
        if isinstance(r, dict):
            lbl = str(r.get('account_label') or '').strip()
            if lbl and lbl not in labels:
                labels.append(lbl)


    ops = _load_json(STATE / "ops_snapshot.json")
    ops_accounts = ops.get("accounts") if isinstance(ops, dict) else None
    if not isinstance(ops_accounts, dict):
        ops_accounts = {}

    # Merge manifest config with ops_snapshot live signals
    for r in rows:
        if not isinstance(r, dict):
            continue
        label = str(r.get('account_label') or '').strip()
        if not label:
            continue

        manifest_enabled = bool(r.get('enabled', True))
        manifest_enable_ai_stack = bool(r.get('enable_ai_stack', True))
        manifest_mode = str(r.get('automation_mode') or 'UNKNOWN').strip()
        is_canary = (manifest_mode.strip().upper() == 'LIVE_CANARY')

        acc = ops_accounts.get(label) if isinstance(ops_accounts, dict) else None
        if not isinstance(acc, dict):
            acc = {}

        sup = acc.get('supervisor_ai_stack') if isinstance(acc.get('supervisor_ai_stack'), dict) else {}
        alive = bool(sup.get('ok')) if isinstance(sup, dict) and sup else False
        pid = sup.get('pid') if isinstance(sup, dict) else None

        enabled = bool(manifest_enabled)
        enable_ai_stack = bool(manifest_enable_ai_stack)

        acc = ops_accounts.get(label) if isinstance(ops_accounts, dict) else None
        if not isinstance(acc, dict):
            acc = {}

        enabled = bool(acc.get("enabled", True)) if acc else True
        enable_ai_stack = bool(acc.get("enable_ai_stack", True)) if acc else True

        sup = acc.get("supervisor_ai_stack") if isinstance(acc.get("supervisor_ai_stack"), dict) else {}
        alive = bool(sup.get("ok")) if isinstance(sup, dict) and sup else False
        pid = sup.get("pid") if isinstance(sup, dict) else None

        subs[label] = {
            "enabled": enabled,
            "enable_ai_stack": enable_ai_stack,
            "automation_mode": manifest_mode,
            "is_canary": bool(is_canary),
            "should_run": bool(enabled and enable_ai_stack),
            "alive": alive,
            "pid": pid,
        }


    # Compute fleet_mode deterministically from SHOULD_RUN subs
    # Precedence: LIVE > LIVE_CANARY > LEARN_DRY > OFF
    active_modes = []
    for _lbl, info in subs.items():
        if isinstance(info, dict) and bool(info.get("should_run")):
            m = str(info.get("automation_mode") or "UNKNOWN").strip().upper()
            active_modes.append(m)

    if "LIVE" in active_modes:
        fleet_mode = "LIVE"
    elif "LIVE_CANARY" in active_modes:
        fleet_mode = "LIVE_CANARY"
    elif "LEARN_DRY" in active_modes:
        fleet_mode = "LEARN_DRY"
    else:
        fleet_mode = "OFF"

    out = {
        "ts_ms": _now_ms(),
        "fleet_mode": fleet_mode,
        "root": str(ROOT),
        "manifest": {"path": str(CFG), "mtime_ms": int(CFG.stat().st_mtime * 1000) if CFG.exists() else None},
        "buses": buses,
        "fleet": {"count": len(labels), "labels": labels, "subs": subs},
        "orchestrator": {"pid": os.getpid(), "cwd": str(Path.cwd())},
    }

    OUT_PATH.write_text(json.dumps(out, indent=2), encoding="utf-8")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
